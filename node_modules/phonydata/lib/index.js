"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.define = exports.defineForObject = exports.PhonyData = void 0;
const format_generator_1 = require("./generator/format-generator");
const parse_generator_1 = require("./generator/parse-generator");
const random_generator_1 = require("./generator/random-generator");
const sequence_generator_1 = require("./generator/sequence-generator");
const weighted_generator_1 = require("./generator/weighted-generator");
const binary_1 = require("./basic/binary");
const boolean_1 = require("./basic/boolean");
const currency_1 = require("./basic/currency");
const date_1 = require("./basic/date");
const functions_1 = require("./basic/functions");
const locale_1 = require("./basic/locale");
const lorem_1 = require("./basic/lorem");
const modifiers_1 = require("./basic/modifiers");
const number_1 = require("./basic/number");
const random_1 = require("./basic/random");
const text_1 = require("./basic/text");
const web_1 = require("./basic/web");
class PhonyData {
    constructor() {
        this.formatGenerator = format_generator_1.formatGenerator;
        this.parseGenerator = parse_generator_1.parseGenerator;
        this.randomGenerator = random_generator_1.randomGenerator;
        this.sequenceGenerator = sequence_generator_1.sequenceGenerator;
        this.weightedGenerator = weighted_generator_1.weightedGenerator;
        this._formatMap = new Map([
            ['#', 'digit'],
            ['A', 'letterUpper'],
            ['a', 'letterLower'],
            ['X', 'hexUpper'],
            ['x', 'hexLower'],
            ['Z', 'alphaNumericUpper'],
            ['z', 'alphaNumericLower'],
        ]);
    }
    define(name, value) {
        if (typeof name === 'string') {
            if (typeof value !== 'undefined') {
                defineForObject(this, name, value);
            }
        }
        else {
            for (const key of Object.keys(name)) {
                defineForObject(this, key, name[key]);
            }
        }
    }
    defineFormatter(formatCharacter, generatorName) {
        this._formatMap.set(formatCharacter, generatorName);
    }
}
exports.PhonyData = PhonyData;
function defineMethod(target, name, value) {
    if (value.length) {
        Object.defineProperty(target, name, {
            configurable: true,
            value: value,
        });
    }
    else {
        Object.defineProperty(target, name, {
            configurable: true,
            get: value,
        });
    }
    Object.defineProperty(target, '_' + name, {
        configurable: true,
        value: value,
    });
}
function defineForObject(target, name, value) {
    if (typeof name === 'object') {
        for (const key of Object.keys(name)) {
            defineForObject(target, key, name[key]);
        }
    }
    else if (Array.isArray(value)) {
        defineMethod(target, name, function () {
            return value[this.index(value.length)];
        });
    }
    else if (typeof value === 'function') {
        defineMethod(target, name, value);
    }
    else {
        defineMethod(target, name, () => value);
    }
}
exports.defineForObject = defineForObject;
function define(name, value) {
    defineForObject(PhonyData.prototype, name, value);
}
exports.define = define;
(0, binary_1.binary)();
(0, boolean_1.boolean)();
(0, currency_1.currency)();
(0, date_1.date)();
(0, functions_1.functions)();
(0, locale_1.locale)();
(0, lorem_1.lorem)();
(0, modifiers_1.modifiers)();
(0, number_1.number)();
(0, random_1.random)();
(0, text_1.text)();
(0, web_1.web)();
